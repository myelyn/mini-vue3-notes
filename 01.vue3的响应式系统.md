### 思路

###### 首先来实现reactive, 目前已经知道的实现原理有这些:

+ reactive是通过Proxy实现属性拦截
+ 区别于vue2的Object.defineProperty在初始化的时候就递归执行，reactive对于对象数据深层嵌套的场景是在get的时候递归执行
+ 用Reflect.get()取值，传入receiver解决了代理对象里面的this指向问题（C-001）
  
*基于之前已经知道的这些信息，自己先写一个最简单的reactive函数实现代理，proxy中的处理方法先实现get和set*

```
const reactive = function(obj) {
  return new Proxy(obj, {
    get(target, key, receiver) {
        const res = Reflect.get(target, key, receiver)
        // 如果返回值是对象，则嵌套执行reactive，否则直接返回这个值
        if (typeof res === 'object') {
          return reactive(res)
        }
      return res
    },
    set(target, key, value, receiver) {
      return Reflect.set(target, key, value ,receiver)
    }
  })
}

// 测试一下
let textP = reactive({
  a: 1,
  b: {
    b1: 2,
    b2: {
      b21: 3,
      b22: 4,
    }
  }
})

console.log(textP.b.b2.b22) // 4
textP.b.b1 = 11
console.log(textP) // { a: 1, b: { b1: 11, b2: { b21: 3, b22: 4 } } }

```

*到此就实现了将一个对象封装成响应式对象。*

###### 再来实现watchEffect

###### 在vue3的使用过程中看到，watchEffect函数可以“立即执行传入的一个函数，同时响应式追踪其依赖，并在其依赖变更时重新运行该函数” (引用文档原话)。
###### 所以想象一下，应该是在调用watchEffect的时候，立即执行了传入的函数，这个传入的函数里面用到了响应式数据的话就会触发对应的get，那么在初次触发get的时候，把这个回调函数添加到这个响应式数据对应的“观察者”中，然后下次触发set的时候，再通知“观察者”，就可以实现响应式追踪了，先按这个思路试着写一下

```

```